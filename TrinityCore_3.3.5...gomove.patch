diff --git a/src/server/game/Entities/GameObject/GameObject.cpp b/src/server/game/Entities/GameObject/GameObject.cpp
index 6f0b9f8..a0e2bea 100644
--- a/src/server/game/Entities/GameObject/GameObject.cpp
+++ b/src/server/game/Entities/GameObject/GameObject.cpp
@@ -146,11 +146,14 @@ void GameObject::AddToWorld()
     }
 }
 
+extern void GOMoveRemoveGO(ObjectGuid const & guid);
 void GameObject::RemoveFromWorld()
 {
     ///- Remove the gameobject from the accessor
     if (IsInWorld())
     {
+        GOMoveRemoveGO(GetGUID());
+
         if (m_zoneScript)
             m_zoneScript->OnGameObjectRemove(this);
 
@@ -206,7 +209,11 @@ bool GameObject::Create(ObjectGuid::LowType guidlow, uint32 name_id, Map* map, u
     if (goinfo->type == GAMEOBJECT_TYPE_TRANSPORT)
         m_updateFlag = (m_updateFlag | UPDATEFLAG_TRANSPORT) & ~UPDATEFLAG_POSITION;
 
-    Object::_Create(guidlow, goinfo->entry, HighGuid::GameObject);
+    static std::atomic<uint32> GOMoveID(0);
+    if (!guidlow)
+        Object::_Create(0, ++GOMoveID, HighGuid::GOMoveObject);
+    else
+        Object::_Create(guidlow, goinfo->entry, HighGuid::GameObject);
 
     m_goInfo = goinfo;
 
diff --git a/src/server/game/Entities/Object/ObjectGuid.h b/src/server/game/Entities/Object/ObjectGuid.h
index 4464442..b23f953 100644
--- a/src/server/game/Entities/Object/ObjectGuid.h
+++ b/src/server/game/Entities/Object/ObjectGuid.h
@@ -57,6 +57,7 @@ enum class HighGuid
     Container      = 0x4000,                      // blizz 4000
     Player         = 0x0000,                      // blizz 0000
     GameObject     = 0xF110,                      // blizz F110
+    GOMoveObject   = GameObject+1,
     Transport      = 0xF120,                      // blizz F120 (for GAMEOBJECT_TYPE_TRANSPORT)
     Unit           = 0xF130,                      // blizz F130
     Pet            = 0xF140,                      // blizz F140
@@ -99,6 +100,7 @@ GUID_TRAIT_MAP_SPECIFIC(HighGuid::Unit)
 GUID_TRAIT_MAP_SPECIFIC(HighGuid::Vehicle)
 GUID_TRAIT_MAP_SPECIFIC(HighGuid::Pet)
 GUID_TRAIT_MAP_SPECIFIC(HighGuid::GameObject)
+GUID_TRAIT_MAP_SPECIFIC(HighGuid::GOMoveObject)
 GUID_TRAIT_MAP_SPECIFIC(HighGuid::DynamicObject)
 GUID_TRAIT_MAP_SPECIFIC(HighGuid::Corpse)
 
@@ -126,7 +128,7 @@ class ObjectGuid
 
         ObjectGuid() : _guid(0) { }
         explicit ObjectGuid(uint64 guid) : _guid(guid) { }
-        ObjectGuid(HighGuid hi, uint32 entry, LowType counter) : _guid(counter ? uint64(counter) | (uint64(entry) << 24) | (uint64(hi) << 48) : 0) { }
+        ObjectGuid(HighGuid hi, uint32 entry, LowType counter) : _guid(hi == HighGuid::GOMoveObject || counter ? uint64(counter) | (uint64(entry) << 24) | (uint64(hi) << 48) : 0) { }
         ObjectGuid(HighGuid hi, LowType counter) : _guid(counter ? uint64(counter) | (uint64(hi) << 48) : 0) { }
 
         operator uint64() const { return _guid; }
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 2922e4e..5991f71 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -1410,6 +1410,7 @@ void AddBattlegroundScripts()
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
 
+void AddSC_GOMove_commandscript();
 #endif
 
 void AddCustomScripts()
@@ -1417,5 +1418,6 @@ void AddCustomScripts()
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
 
+    AddSC_GOMove_commandscript();
 #endif
 }
diff --git a/src/server/scripts/Custom/CMakeLists.txt b/src/server/scripts/Custom/CMakeLists.txt
index 595ff80..fa53226 100644
--- a/src/server/scripts/Custom/CMakeLists.txt
+++ b/src/server/scripts/Custom/CMakeLists.txt
@@ -13,6 +13,8 @@
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
 #  ${sources_Custom}
+  Custom/GOMove/GOMove.cpp
+  Custom/GOMove/GOMove.h
 )
 
 message("  -> Prepared: Custom")
diff --git a/src/server/scripts/Custom/GOMove/GOMove.cpp b/src/server/scripts/Custom/GOMove/GOMove.cpp
new file mode 100644
index 0000000..d7dfec3
--- /dev/null
+++ b/src/server/scripts/Custom/GOMove/GOMove.cpp
@@ -0,0 +1,583 @@
+/*
+GOMove By Rochet2
+Original idea by Mordred
+
+http://rochet2.github.io/
+*/
+
+#include <math.h>
+#include <set>
+#include <sstream>
+#include <string>
+#include "Chat.h"
+#include "GameObject.h"
+#include "Language.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "Object.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "Position.h"
+#include "RBAC.h"
+#include "ScriptMgr.h"
+#include "SpellScript.h"
+#include "WorldPacket.h"
+#include "GOMove.h"
+
+// global
+void GOMoveRemoveGO(ObjectGuid const & guid)
+{
+    bool isHex = GOMove::IsTemporary(guid);
+    if (isHex)
+        GOMove::Store.RemoveTemp(guid.GetEntry());
+
+    for (auto session : sWorld->GetAllSessions())
+        if (Player* player = session.second->GetPlayer())
+            GOMove::SendRemove(player, isHex ? guid.GetEntry() : guid.GetCounter(), isHex);
+}
+
+bool GOMove::IsTemporary(ObjectGuid const & guid)
+{
+    return (guid.GetHigh() == HighGuid::GOMoveObject);
+}
+
+void GOMove::SendAddonMessage(Player * player, const char * msg)
+{
+    if (!player || !msg)
+        return;
+
+    WorldPacket data; // Needs a custom built packet since TC doesnt send guid
+    uint32 messageLength = (uint32)strlen(msg) + 1;
+    data.Initialize(SMSG_MESSAGECHAT, 100);
+    data << uint8(CHAT_MSG_SYSTEM);
+    data << int32(LANG_ADDON);
+    data << uint64(player->GetGUID());
+    data << uint32(0);
+    data << uint64(player->GetGUID());
+    data << uint32(messageLength);
+    data << msg;
+    data << uint8(0);
+    player->GetSession()->SendPacket(&data);
+}
+
+GameObject * GOMove::GetGameObject(Player * player, uint32 GObjectID, bool isHex)
+{
+    if (isHex)
+        return Store.GetTemp(player, GObjectID);
+    else if (GameObjectData const* gameObjectData = sObjectMgr->GetGOData(GObjectID))
+        return ChatHandler(player->GetSession()).GetObjectGlobalyWithGuidOrNearWithDbGuid(GObjectID, gameObjectData->id);
+    return nullptr;
+}
+
+void GOMove::SendAdd(Player * player, uint32 GObjectID, bool isHex)
+{
+    GameObject* object = GOMove::GetGameObject(player, GObjectID, isHex);
+    if (!object)
+        return;
+
+    char msg[256];
+    if (!isHex)
+        snprintf(msg, 256, "GOMOVE|ADD|%u|%s|%u", GObjectID, object->GetName().c_str(), object->GetEntry());
+    else
+        snprintf(msg, 256, "GOMOVE|ADD|%#x|%s|%u", GObjectID, object->GetName().c_str(), object->GetEntry());
+
+    SendAddonMessage(player, msg);
+}
+
+void GOMove::SendRemove(Player * player, uint32 GObjectID, bool isHex)
+{
+    char msg[256];
+    if (!isHex)
+        snprintf(msg, 256, "GOMOVE|REMOVE|%u||0", GObjectID);
+    else
+        snprintf(msg, 256, "GOMOVE|REMOVE|%#x||0", GObjectID);
+
+    SendAddonMessage(player, msg);
+}
+
+void GOMove::SendSwap(Player * player, uint32 GObjectID1, bool isHex1, uint32 GObjectID2, bool isHex2)
+{
+    char msg[256];
+    if (!isHex1 && !isHex2)
+        snprintf(msg, 256, "GOMOVE|SWAP|%u||%u", GObjectID1, GObjectID2);
+    else if (isHex1 && isHex2)
+        snprintf(msg, 256, "GOMOVE|SWAP|%#x||%#x", GObjectID1, GObjectID2);
+    else if (!isHex1 && isHex2)
+        snprintf(msg, 256, "GOMOVE|SWAP|%u||%#x", GObjectID1, GObjectID2);
+    else if (isHex1 && !isHex2)
+        snprintf(msg, 256, "GOMOVE|SWAP|%#x||%u", GObjectID1, GObjectID2);
+    SendAddonMessage(player, msg);
+}
+
+GameObject * GOMove::CreateTemp(Player * obj, uint32 entry, float x, float y, float z, float o, uint32 p, uint32 respawnTime)
+{
+    if (!obj->IsInWorld())
+        return nullptr;
+
+    GameObjectTemplate const* goinfo = sObjectMgr->GetGameObjectTemplate(entry);
+    if (!goinfo)
+        return nullptr;
+
+    float rotation2 = std::sin(o / 2);
+    float rotation3 = std::cos(o / 2);
+
+    Map* map = obj->GetMap();
+    GameObject* go = new GameObject();
+    if (!go->Create(0, entry, map, p, x, y, z, o, 0, 0, rotation2, rotation3, 100, GO_STATE_READY))
+    {
+        delete go;
+        return nullptr;
+    }
+
+    go->SetRespawnTime(respawnTime);
+    obj->AddGameObject(go);
+    map->AddToMap(go);
+
+    Store.AddTemp(go->GetGUID().GetEntry(), go);
+    return go;
+}
+
+void GOMove::DeleteGameObject(GameObject * object)
+{
+    if (!object)
+        return;
+
+    ObjectGuid ownerGuid = object->GetOwnerGUID();
+    if (ownerGuid != ObjectGuid::Empty)
+    {
+        Unit* owner = ObjectAccessor::GetUnit(*object, ownerGuid);
+        if (owner && ownerGuid.IsPlayer())
+            owner->RemoveGameObject(object, false);
+    }
+    object->SetRespawnTime(0);
+    object->Delete();
+    object->DeleteFromDB();
+}
+
+GameObject * GOMove::SpawnGameObject(Player* player, float x, float y, float z, float o, uint32 p, uint32 entry)
+{
+    if (!player || !entry)
+        return nullptr;
+
+    GameObject* spawned = CreateTemp(player, entry, x, y, z, o, p, 0);
+    if (spawned)
+        SendAdd(player, spawned->GetGUID().GetEntry(), true);
+    return spawned;
+}
+
+GameObject * GOMove::MoveGameObject(Player* player, float x, float y, float z, float o, uint32 p, uint32 GObjectID, bool isHex)
+{
+    if (!player)
+        return nullptr;
+
+    GameObject* object = GetGameObject(player, GObjectID, isHex);
+    if (!object)
+    {
+        SendRemove(player, GObjectID, isHex);
+        return nullptr;
+    }
+
+    GameObject* spawned = CreateTemp(player, object->GetEntry(), x, y, z, o, p, 0);
+
+    if (!spawned)
+        return nullptr;
+
+    SendSwap(player, GObjectID, isHex, spawned->GetGUID().GetEntry(), true);
+    DeleteGameObject(object);
+    return spawned;
+}
+
+void GOMove::SaveGameObject(Player * player, uint32 GObjectID, bool isHex)
+{
+    GameObject* object = GetGameObject(player, GObjectID, isHex);
+    if (!object)
+        return;
+
+    if (!isHex)
+    {
+        object->SaveToDB();
+        return;
+    }
+
+    Map* map = player->GetMap();
+    GameObject* saved = new GameObject();
+    uint32 guidLow = map->GenerateLowGuid<HighGuid::GameObject>();
+    float x, y, z, o;
+    object->GetPosition(x, y, z, o);
+    if (!saved->Create(guidLow, object->GetEntry(), map, object->GetPhaseMask(), x, y, z, o, 0.0f, 0.0f, 0.0f, 0.0f, 0, GO_STATE_READY))
+    {
+        delete saved;
+        return;
+    }
+    saved->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), saved->GetPhaseMask());
+    guidLow = saved->GetSpawnId();
+    delete saved;
+    saved = new GameObject();
+    if (!saved->LoadGameObjectFromDB(guidLow, map))
+    {
+        delete saved;
+        return;
+    }
+    sObjectMgr->AddGameobjectToGrid(guidLow, sObjectMgr->GetGOData(guidLow));
+
+    SendSwap(player, GObjectID, isHex, guidLow, false);
+    DeleteGameObject(object);
+}
+
+void GameObjectStore::SpawnQueAdd(ObjectGuid const & guid, uint32 entry)
+{
+    WriteGuard lock(_objectsToSpawnLock);
+    objectsToSpawn[guid] = entry;
+}
+
+void GameObjectStore::SpawnQueRem(ObjectGuid const & guid)
+{
+    WriteGuard lock(_objectsToSpawnLock);
+    objectsToSpawn.erase(guid);
+}
+
+uint32 GameObjectStore::SpawnQueGet(ObjectGuid const & guid)
+{
+    WriteGuard lock(_objectsToSpawnLock);
+    auto it = objectsToSpawn.find(guid);
+    if (it != objectsToSpawn.end())
+        return it->second;
+    return 0;
+}
+
+void GameObjectStore::AddTemp(uint32 GObjectID, GameObject * go)
+{
+    if (!go)
+        return;
+    WriteGuard lock(_tempObjectsLock);
+    tempObjects[GObjectID] = go;
+}
+
+void GameObjectStore::RemoveTemp(uint32 GObjectID)
+{
+    {
+        WriteGuard lock(_tempObjectsLock);
+        tempObjects.erase(GObjectID);
+    }
+}
+
+GameObject * GameObjectStore::GetTemp(Player* player, uint32 GObjectID)
+{
+    WriteGuard lock(_tempObjectsLock);
+    auto it = tempObjects.find(GObjectID);
+    if (it != tempObjects.end())
+        return player->IsInMap(it->second) ? it->second : nullptr;
+    return nullptr;
+}
+
+void GameObjectStore::SendSelectTempInRange(Player * player, float range)
+{
+    std::vector<uint32> toSend;
+    {
+        WriteGuard lock(_tempObjectsLock);
+        for (auto& go : tempObjects)
+        {
+            if (go.second->IsWithinDistInMap(player, range))
+                toSend.push_back(go.first);
+        }
+    }
+
+    for (uint32 low : toSend)
+        GOMove::SendAdd(player, low, true);
+}
+
+GameObject * GameObjectStore::GetClosestTemp(Player * player, GameObject * closestReal)
+{
+    GameObject* obj = closestReal;
+    WriteGuard lock(_tempObjectsLock);
+    for (auto& go : tempObjects)
+    {
+        if (obj && go.second->GetDistance(player) > obj->GetDistance(player))
+            continue;
+        obj = go.second;
+    }
+    return obj;
+}
+
+class GOMove_commandscript : public CommandScript
+{
+public:
+    GOMove_commandscript() : CommandScript("GOMove_commandscript")
+    {
+    }
+
+    enum commandIDs
+    {
+        TEST,
+        SELECTNEAR,
+        DELET,
+        X,
+        Y,
+        Z,
+        O,
+        GROUND,
+        RESPAWN,
+        GOTO,
+        FACE,
+        SAVE,
+
+        SPAWN,
+        NORTH,
+        EAST,
+        SOUTH,
+        WEST,
+        NORTHEAST,
+        NORTHWEST,
+        SOUTHEAST,
+        SOUTHWEST,
+        UP,
+        DOWN,
+        LEFT,
+        RIGHT,
+        PHASE,
+        SELECTALLNEAR,
+        SPAWNSPELL,
+    };
+
+    std::vector<ChatCommand> GetCommands() const override
+    {
+        static std::vector<ChatCommand> GOMoveCommandTable =
+        {
+            { "gomove", rbac::RBAC_PERM_COMMAND_GOBJECT_ADD_TEMP, false, &GOMove_Command, "" },
+        };
+        return GOMoveCommandTable;
+    }
+
+    static bool GOMove_Command(ChatHandler* handler, const char* args)
+    {
+        if (!args)
+            return false;
+
+        char* ID_t = strtok((char*)args, " ");
+        if (!ID_t)
+            return false;
+        uint32 ID = static_cast<uint32>(atoul(ID_t));
+
+        char* GObjectID_C = strtok(nullptr, " ");
+        uint32 GObjectID = 0;
+        bool isHex = false;
+        if (GObjectID_C)
+        {
+            GObjectID = strtoul(GObjectID_C, nullptr, 0); // can take in hex as well as dec
+            isHex = (std::string(GObjectID_C).find("0x") != std::string::npos);
+        }
+
+        char* ARG_t = strtok(nullptr, " ");
+        uint32 ARG = 0;
+        if (ARG_t)
+            ARG = static_cast<uint32>(atoul(ARG_t));
+
+        WorldSession* session = handler->GetSession();
+        if (!session)
+            return false;
+        Player* player = session->GetPlayer();
+
+        if (ID < SPAWN) // no args
+        {
+            if (ID >= DELET && ID <= GOTO) // has target (needs retrieve gameobject)
+            {
+                GameObject* target = GOMove::GetGameObject(player, GObjectID, isHex);
+                if (!target)
+                    ChatHandler(player->GetSession()).PSendSysMessage("Object GUID: %u not found. Temp(%u)", GObjectID, isHex ? 1 : 0);
+                else
+                {
+                    float x, y, z, o;
+                    target->GetPosition(x, y, z, o);
+                    uint32 p = target->GetPhaseMask();
+                    switch (ID)
+                    {
+                    case DELET: GOMove::DeleteGameObject(target); GOMove::SendRemove(player, GObjectID, isHex); break;
+                    case X: GOMove::MoveGameObject(player, player->GetPositionX(), y, z, o, p, GObjectID, isHex);       break;
+                    case Y: GOMove::MoveGameObject(player, x, player->GetPositionY(), z, o, p, GObjectID, isHex);       break;
+                    case Z: GOMove::MoveGameObject(player, x, y, player->GetPositionZ(), o, p, GObjectID, isHex);       break;
+                    case O: GOMove::MoveGameObject(player, x, y, z, player->GetOrientation(), p, GObjectID, isHex);     break;
+                    case RESPAWN: GOMove::SpawnGameObject(player, x, y, z, o, p, target->GetEntry());                   break;
+                    case GOTO:
+                    {
+                        // stop flight if need
+                        if (player->IsInFlight())
+                        {
+                            player->GetMotionMaster()->MovementExpired();
+                            player->CleanupAfterTaxiFlight();
+                        }
+                        // save only in non-flight case
+                        else
+                            player->SaveRecallPosition();
+                        player->TeleportTo(target->GetMapId(), x, y, z, o);
+                    } break;
+                    case GROUND:
+                    {
+                        float ground = target->GetMap()->GetHeight(target->GetPhaseMask(), x, y, MAX_HEIGHT);
+                        if (ground != INVALID_HEIGHT)
+                            GOMove::MoveGameObject(player, x, y, ground, o, p, GObjectID, isHex);
+                    } break;
+                    }
+                }
+            }
+            else
+            {
+                switch (ID)
+                {
+                case TEST:
+                    session->SendAreaTriggerMessage("%s", player->GetName().c_str());
+                    break;
+                case FACE:
+                {
+                    float const piper2 = float(M_PI) / 2.0f;
+                    float const multi = player->GetOrientation() / piper2;
+                    float const multi_int = floor(multi);
+                    float const new_ori = (multi - multi_int > 0.5f) ? (multi_int + 1)*piper2 : multi_int*piper2;
+                    player->SetFacingTo(new_ori);
+                } break;
+                case SAVE:
+                    GOMove::SaveGameObject(player, GObjectID, isHex);
+                    break;
+                case SELECTNEAR:
+                {
+                    GameObject* object = GOMove::Store.GetClosestTemp(player, handler->GetNearbyGameObject());
+                    if (!object)
+                        ChatHandler(player->GetSession()).PSendSysMessage("No objects found");
+                    else
+                    {
+                        if (GOMove::IsTemporary(object->GetGUID()))
+                            GOMove::SendAdd(player, object->GetGUID().GetEntry(), true);
+                        else
+                            GOMove::SendAdd(player, object->GetSpawnId() ? object->GetSpawnId() : object->GetGUID().GetCounter(), false);
+                        session->SendAreaTriggerMessage("Selected %s", object->GetName().c_str());
+                    }
+                } break;
+                }
+            }
+        }
+        else if (ARG && ID >= SPAWN)
+        {
+            if (ID >= NORTH && ID <= PHASE)
+            {
+                GameObject* target = GOMove::GetGameObject(player, GObjectID, isHex);
+                if (!target)
+                    ChatHandler(player->GetSession()).PSendSysMessage("Object GUID: %u not found. Temporary: %s", GObjectID, isHex ? "true" : "false");
+                else
+                {
+                    float x, y, z, o;
+                    target->GetPosition(x, y, z, o);
+                    uint32 p = target->GetPhaseMask();
+                    switch (ID)
+                    {
+                    case NORTH: GOMove::MoveGameObject(player, x + ((float)ARG / 100), y, z, o, p, GObjectID, isHex);                            break;
+                    case EAST: GOMove::MoveGameObject(player, x, y - ((float)ARG / 100), z, o, p, GObjectID, isHex);                             break;
+                    case SOUTH: GOMove::MoveGameObject(player, x - ((float)ARG / 100), y, z, o, p, GObjectID, isHex);                            break;
+                    case WEST: GOMove::MoveGameObject(player, x, y + ((float)ARG / 100), z, o, p, GObjectID, isHex);                             break;
+                    case NORTHEAST: GOMove::MoveGameObject(player, x + ((float)ARG / 100), y - ((float)ARG / 100), z, o, p, GObjectID, isHex);   break;
+                    case SOUTHEAST: GOMove::MoveGameObject(player, x - ((float)ARG / 100), y - ((float)ARG / 100), z, o, p, GObjectID, isHex);   break;
+                    case SOUTHWEST: GOMove::MoveGameObject(player, x - ((float)ARG / 100), y + ((float)ARG / 100), z, o, p, GObjectID, isHex);   break;
+                    case NORTHWEST: GOMove::MoveGameObject(player, x + ((float)ARG / 100), y + ((float)ARG / 100), z, o, p, GObjectID, isHex);   break;
+                    case UP: GOMove::MoveGameObject(player, x, y, z + ((float)ARG / 100), o, p, GObjectID, isHex);                               break;
+                    case DOWN: GOMove::MoveGameObject(player, x, y, z - ((float)ARG / 100), o, p, GObjectID, isHex);                             break;
+                    case RIGHT: GOMove::MoveGameObject(player, x, y, z, o - ((float)ARG / 100), p, GObjectID, isHex);                            break;
+                    case LEFT: GOMove::MoveGameObject(player, x, y, z, o + ((float)ARG / 100), p, GObjectID, isHex);                             break;
+                    case PHASE: GOMove::MoveGameObject(player, x, y, z, o, ARG, GObjectID, isHex);                                               break;
+                    }
+                }
+            }
+            else
+            {
+                switch (ID)
+                {
+                case SPAWN:
+                {
+                    if (GOMove::SpawnGameObject(player, player->GetPositionX(), player->GetPositionY(), player->GetPositionZ(), player->GetOrientation(), player->GetPhaseMaskForSpawn(), ARG))
+                        GOMove::Store.SpawnQueAdd(player->GetGUID(), ARG);
+                } break;
+                case SPAWNSPELL:
+                {
+                    GOMove::Store.SpawnQueAdd(player->GetGUID(), ARG);
+                } break;
+                case SELECTALLNEAR:
+                {
+                    if (ARG > 5000)
+                        ARG = 5000;
+
+                    QueryResult result = WorldDatabase.PQuery("SELECT guid, (POW(position_x - '%f', 2) + POW(position_y - '%f', 2) + POW(position_z - '%f', 2)) AS order_ FROM gameobject WHERE map = '%u' AND position_x BETWEEN '%f'-'%u' AND '%f'+'%u' AND position_y BETWEEN '%f'-'%u' AND '%f'+'%u' AND position_z BETWEEN '%f'-'%u' AND '%f'+'%u' ORDER BY order_ ASC LIMIT 100",
+                        player->GetPositionX(), player->GetPositionY(), player->GetPositionZ(), player->GetMapId(), player->GetPositionX(), ARG, player->GetPositionX(), ARG, player->GetPositionY(), ARG, player->GetPositionY(), ARG, player->GetPositionZ(), ARG, player->GetPositionZ(), ARG);
+
+                    if (result)
+                    {
+                        do
+                        {
+                            Field* fields = result->Fetch();
+                            uint32 guidLow = fields[0].GetUInt32();
+
+                            if (GOMove::GetGameObject(player, guidLow, false))
+                                GOMove::SendAdd(player, guidLow, false);
+                        } while (result->NextRow());
+                    }
+                    GOMove::Store.SendSelectTempInRange(player, ARG);
+                } break;
+                }
+            }
+        }
+        else
+            return false;
+        return true;
+    }
+};
+
+// possible spells:
+// 27651, 897
+
+class GOMove_spell_place : public SpellScriptLoader
+{
+public:
+    GOMove_spell_place() : SpellScriptLoader("GOMove_spell_place") { }
+
+    class GOMove_spellscript : public SpellScript
+    {
+        PrepareSpellScript(GOMove_spellscript);
+
+        void HandleAfterCast()
+        {
+            if (!GetCaster())
+                return;
+            Player* player = GetCaster()->ToPlayer();
+            if (!player)
+                return;
+            const WorldLocation* summonPos = GetExplTargetDest();
+            if (!summonPos)
+                return;
+            if (uint32 entry = GOMove::Store.SpawnQueGet(player->GetGUID()))
+                GOMove::SpawnGameObject(player, summonPos->GetPositionX(), summonPos->GetPositionY(), summonPos->GetPositionZ(), player->GetOrientation(), player->GetPhaseMaskForSpawn(), entry);
+        }
+
+        void Register() override
+        {
+            AfterCast += SpellCastFn(GOMove_spellscript::HandleAfterCast);
+        }
+    };
+
+    SpellScript* GetSpellScript() const override
+    {
+        return new GOMove_spellscript();
+    }
+};
+
+class GOMove_player_track : public PlayerScript
+{
+public:
+    GOMove_player_track() : PlayerScript("GOMove_player_track") { }
+
+    void OnLogout(Player* player) override
+    {
+        GOMove::Store.SpawnQueRem(player->GetGUID());
+    }
+};
+
+void AddSC_GOMove_commandscript()
+{
+    new GOMove_commandscript();
+    new GOMove_spell_place();
+}
diff --git a/src/server/scripts/Custom/GOMove/GOMove.h b/src/server/scripts/Custom/GOMove/GOMove.h
new file mode 100644
index 0000000..5d1f765
--- /dev/null
+++ b/src/server/scripts/Custom/GOMove/GOMove.h
@@ -0,0 +1,62 @@
+/*
+GOMove By Rochet2
+Original idea by Mordred
+
+http://rochet2.github.io/
+*/
+
+#ifndef GOMOVE_H
+#define GOMOVE_H
+
+#include "Define.h"
+#include "ObjectGuid.h"
+#include <memory>
+#include <mutex>
+#include <unordered_map>
+
+class Player;
+class GameObject;
+
+class GameObjectStore
+{
+public:
+    typedef std::mutex LockType;
+    typedef std::lock_guard<LockType> WriteGuard;
+
+    void SpawnQueAdd(ObjectGuid const& guid, uint32 entry);
+    void SpawnQueRem(ObjectGuid const& guid);
+    uint32 SpawnQueGet(ObjectGuid const& guid);
+
+    void AddTemp(uint32 GObjectID, GameObject* go);
+    void RemoveTemp(uint32 GObjectID);
+    GameObject* GetTemp(Player* player, uint32 GObjectID);
+
+    void SendSelectTempInRange(Player* player, float range);
+    GameObject* GetClosestTemp(Player* player, GameObject* obj);
+
+private:
+    LockType _tempObjectsLock;
+    LockType _objectsToSpawnLock;
+    std::unordered_map<uint32, GameObject*> tempObjects;
+    std::unordered_map<ObjectGuid, uint32> objectsToSpawn;
+};
+
+namespace GOMove
+{
+    GameObjectStore Store;
+    bool IsTemporary(ObjectGuid const& guid);
+
+    void SendAdd(Player* player, uint32 GObjectID, bool isHex);
+    void SendRemove(Player* player, uint32 GObjectID, bool isHex);
+    void SendSwap(Player * player, uint32 GObjectID1, bool isHex1, uint32 GObjectID2, bool isHex2);
+    void SendAddonMessage(Player* player, const char* msg);
+
+    void DeleteGameObject(GameObject* object);
+    void SaveGameObject(Player* player, uint32 GObjectID, bool isHex);
+    GameObject* GetGameObject(Player* player, uint32 GObjectID, bool isHex);
+    GameObject* SpawnGameObject(Player* player, float x, float y, float z, float o, uint32 p, uint32 entry);
+    GameObject* MoveGameObject(Player* player, float x, float y, float z, float o, uint32 p, uint32 GObjectID, bool isHex);
+    GameObject* CreateTemp(Player* obj, uint32 entry, float x, float y, float z, float o, uint32 p, uint32 respawnTime);
+}
+
+#endif
\ No newline at end of file
diff --git a/src/server/scripts/Custom/GOMove/GOMove/GOMove.toc b/src/server/scripts/Custom/GOMove/GOMove/GOMove.toc
new file mode 100644
index 0000000..8fd4a9c
--- /dev/null
+++ b/src/server/scripts/Custom/GOMove/GOMove/GOMove.toc
@@ -0,0 +1,10 @@
+## Interface: 30300
+## Title: GOMove UI Interface Addon
+## Author: Rochet2
+
+## SavedVariables: GOMoveSV
+# change SavedVariables to SavedVariablesPerCharacter if you want favourite list per char
+
+GOMoveFunctions.lua
+GOMoveScripts.lua
+MapButton.xml
diff --git a/src/server/scripts/Custom/GOMove/GOMove/GOMoveFunctions.lua b/src/server/scripts/Custom/GOMove/GOMove/GOMoveFunctions.lua
new file mode 100644
index 0000000..cce842f
--- /dev/null
+++ b/src/server/scripts/Custom/GOMove/GOMove/GOMoveFunctions.lua
@@ -0,0 +1,239 @@
+GOMove = {Frames = {}, Inputs = {}}
+
+function GOMove:Update()
+    for k, Frame in ipairs(GOMove.Frames) do
+        if(Frame.Update) then
+            Frame:Update()
+        end
+    end
+end
+
+function GOMove:Tonumber(val) -- returns nil if the value is not a number or 0x starting hex
+    if(type(val) == "string") then
+        if(val:find("0x") == 1) then
+            return tonumber(val, 16), true
+        end
+    end
+    return tonumber(val), false
+end
+
+function GOMove:CreateFrame(name, width, height, DataTable, both)
+    local Frame = CreateFrame("Frame", name, UIParent)
+    Frame:SetMovable(true)
+    Frame:EnableMouse(true)
+    Frame:RegisterForDrag("LeftButton")
+    Frame:SetScript("OnDragStart", Frame.StartMoving)
+    Frame:SetScript("OnDragStop", Frame.StopMovingOrSizing)
+    Frame:SetScript("OnHide", Frame.StopMovingOrSizing)
+    Frame:SetSize(width, height)
+    Frame:SetPoint("CENTER")
+    Frame.ButtonCount = math.floor((height-32)/16)
+    Frame:SetBackdrop({
+        bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background", tile = true, tileSize = 16,
+        edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border", edgeSize = 16,
+        insets = { left = 4, right = 4, top = 4, bottom = 4 },
+    })
+    local NameFrame = CreateFrame("Frame", name.."_Name", Frame)
+    NameFrame:SetHeight(16)
+    NameFrame:SetWidth(width-16)
+    NameFrame.text = NameFrame:CreateFontString()
+    NameFrame.text:SetFont("Fonts\\MORPHEUS.ttf", 14)
+    NameFrame.text:SetTextColor(0.8, 0.2, 0.2)
+    NameFrame.text:SetJustifyH("LEFT")
+    NameFrame.text:SetAllPoints()
+    NameFrame.text:SetText(name:gsub("_", " "))
+    NameFrame:SetPoint("TOPLEFT", Frame, "TOPLEFT", 8, -8)
+    NameFrame:Show()
+    Frame.NameFrame = NameFrame
+    local CloseButton = CreateFrame("Button", name.."_CloseButton", Frame)
+    CloseButton:SetSize(25, 25)
+    CloseButton:SetNormalTexture("Interface\\Buttons\\UI-Panel-MinimizeButton-Up")
+    CloseButton:SetPushedTexture("Interface\\Buttons\\UI-Panel-MinimizeButton-Down")
+    CloseButton:SetHighlightTexture("Interface\\Buttons\\UI-Panel-MinimizeButton-Highlight")
+    CloseButton:SetPoint("TOPRIGHT", Frame, "TOPRIGHT", 0, 0)
+    CloseButton:SetScript("OnClick", function() Frame:Hide() end)
+
+    if(DataTable) then
+        Frame.DataTable = DataTable
+        function Frame:Update()
+            local maxValue = #DataTable
+            FauxScrollFrame_Update(self.ScrollBar, maxValue, self.ButtonCount, 16, nil, nil, nil, nil, nil, nil, true)
+            local offset = FauxScrollFrame_GetOffset(self.ScrollBar)
+            for Button = 1, self.ButtonCount do
+                local value = Button + offset
+                if value <= maxValue then
+                    local Button = self.Buttons[Button]
+                    local Label = DataTable[value][1]
+                    if(DataTable.NameWidth and strlen(DataTable[value][1]) > DataTable.NameWidth) then
+                        Label = DataTable[value][1]:sub(0, DataTable.NameWidth-2)..".."
+                    end
+                    if(not both) then
+                        Button:SetText(Label)
+                    else
+                        Button:SetText(DataTable[value][2].." "..Label)
+                    end
+                    Button.MiscButton:Show()
+                    Button:Show()
+                else
+                    self.Buttons[Button]:Hide()
+                    self.Buttons[Button].MiscButton:Hide()
+                end
+                if(Frame.UpdateScript) then
+                    Frame:UpdateScript(Button)
+                end
+            end
+        end
+
+        local ScrollBar = CreateFrame("ScrollFrame", "$parent_ScrollBar", Frame, "FauxScrollFrameTemplate")
+        ScrollBar:SetPoint("TOPLEFT", 0, -24) -- -8
+        ScrollBar:SetPoint("BOTTOMRIGHT", -30, 8)
+
+        ScrollBar:SetScript("OnVerticalScroll", function(self, offset)
+            self.offset = math.floor(offset / 16 + 0.5)
+            Frame:Update()
+        end)
+
+        ScrollBar:SetScript("OnShow", function()
+            Frame:Update()
+        end)
+
+        Frame.ScrollBar = ScrollBar
+
+        local Buttons = setmetatable({}, { __index = function(t, i)
+            local Button = CreateFrame("Button", "$parent_Button"..i, Frame)
+            Button:SetSize(width-55, 16)
+            Button:SetNormalFontObject(GameFontHighlightLeft)
+            if i == 1 then
+                Button:SetPoint("TOPLEFT", ScrollBar, 8, 0)
+            else
+                Button:SetPoint("TOPLEFT", Frame.Buttons[i-1], "BOTTOMLEFT")
+            end
+            Button:SetScript("OnClick", function(self) if(Frame.ButtonOnClick) then Frame:ButtonOnClick(i) end end)
+            local MiscButton = CreateFrame("Button", "$parent_Button"..i.."_Misc", Frame)
+            MiscButton:SetSize(16, 16)
+            MiscButton:SetNormalTexture("Interface\\Buttons\\UI-MinusButton-Disabled")
+            MiscButton:SetPushedTexture("Interface\\Buttons\\UI-MinusButton-Down")
+            MiscButton:SetHighlightTexture("Interface\\Buttons\\UI-MinusButton-Up")
+            MiscButton:SetNormalFontObject(GameFontHighlightLeft)
+            MiscButton:SetPoint("TOPLEFT", Button, "TOPRIGHT", 0, 0)
+            MiscButton:SetScript("OnClick", function(self) if(Frame.MiscOnClick) then Frame:MiscOnClick(i) end end)
+            Button.MiscButton = MiscButton
+            rawset(t, i, Button)
+            return Button
+        end })
+
+        Frame.Buttons = Buttons
+        Frame:Update()
+    end
+    function Frame:Position(FramePoint, Parent, ParentPoint, Ox, Oy)
+        Frame.Default = {FramePoint, Parent, ParentPoint, Ox, Oy}
+        Frame:SetPoint(FramePoint, Parent, ParentPoint, Ox, Oy)
+    end
+    table.insert(GOMove.Frames, Frame)
+    return Frame
+end
+
+function GOMove:CreateButton(Frame, name, width, height, Ox, Oy)
+    local Button = CreateFrame("Button", Frame:GetName().."_"..name, Frame, "UIPanelButtonTemplate")
+    Button:SetSize(width, height)
+    Button:SetText(name)
+    Button:SetPoint("TOP", Frame, "TOP", Ox, Oy-10)
+    Button:SetScript("OnClick", function(self) if(self.OnClick) then self:OnClick(Frame) end end)
+    return Button
+end
+
+function GOMove:CreateInput(Frame, name, width, height, Ox, Oy, letters, default)
+    local Input = CreateFrame("EditBox", Frame:GetName().."_"..name, Frame, "InputBoxTemplate")
+    Input:SetSize(width, height)
+    Input:SetPoint("TOP", Frame, "TOP", Ox+2.5, Oy-10)
+    Input:SetAutoFocus(false)
+    Input:SetNumeric(true)
+    Input:SetMaxLetters(letters)
+    Input:SetScript("OnEnterPressed", function() Input:ClearFocus() end)
+    Input:SetScript("OnEscapePressed", function() Input:ClearFocus() end)
+    if(default) then
+        Input:SetNumber(default)
+    end
+    table.insert(GOMove.Inputs, Input)
+    return Input
+end
+
+local trinityID = {}
+local TIDs = 0
+local function TID(name, reqguid, onetime)
+    trinityID[name] = {TIDs, reqguid, onetime}
+    TIDs = TIDs+1
+end
+
+-- NEED to be in order(same as core)
+TID("TEST"              ,   false   ,   true    ) -- unused
+TID("SELECTNEAR"        ,   false   ,   true    )
+TID("DELETE"            ,   true    ,   true    )
+TID("X"                 ,   true    ,   false   )
+TID("Y"                 ,   true    ,   false   )
+TID("Z"                 ,   true    ,   false   )
+TID("O"                 ,   true    ,   false   )
+TID("GROUND"            ,   true    ,   false   )
+TID("RESPAWN"           ,   true    ,   true    )
+TID("GOTO"              ,   true    ,   true    )
+TID("FACE"              ,   false   ,   true    )
+TID("SAVE"              ,   true    ,   true    )
+
+TID("SPAWN"             ,   false   ,   true    )
+TID("NORTH"             ,   true    ,   false   )
+TID("EAST"              ,   true    ,   false   )
+TID("SOUTH"             ,   true    ,   false   )
+TID("WEST"              ,   true    ,   false   )
+TID("NORTHEAST"         ,   true    ,   false   )
+TID("NORTHWEST"         ,   true    ,   false   )
+TID("SOUTHEAST"         ,   true    ,   false   )
+TID("SOUTHWEST"         ,   true    ,   false   )
+TID("UP"                ,   true    ,   false   )
+TID("DOWN"              ,   true    ,   false   )
+TID("LEFT"              ,   true    ,   false   )
+TID("RIGHT"             ,   true    ,   false   )
+TID("PHASE"             ,   true    ,   false   )
+TID("SELECTALLNEAR"     ,   false   ,   true    )
+TID("SPAWNSPELL"        ,   false   ,   true    )
+--TID("COPYSEL"         ,   false   ,   false   )
+--TID("COPY"            ,   false   ,   false   )
+--TID("BIG"             ,   false   ,   false   )
+--TID("SMALL"           ,   false   ,   false   )
+
+function GOMove:Move(ID, input)
+    if(UnitIsDeadOrGhost("player")) then
+        NotWhileDeadError()
+        return
+    end
+    for k, inputfield in ipairs(GOMove.Inputs) do
+        inputfield:ClearFocus()
+    end
+    local ARG = 0
+    if(input) then
+        ARG = input
+    end
+    -- SendAddonMessage("$GOMOVE$,"..ID, ARG, "WHISPER", UnitName("player"))
+    if(not trinityID[ID] or not tonumber(trinityID[ID][1])) then
+        return
+    end
+    if(not trinityID[ID][2]) then
+        SendAddonMessage(".gomove "..trinityID[ID][1].." "..(0).." "..ARG, "", "WHISPER", UnitName("player"))
+    elseif(trinityID[ID][3] and GOMove:Tonumber(ARG) and GOMove:Tonumber(ARG) > 0) then
+        SendAddonMessage(".gomove "..trinityID[ID][1].." "..ARG.." "..(0), "", "WHISPER", UnitName("player"))
+    else
+        local did = false
+        for GUID, NAME in pairs(GOMove.Selected) do
+            if(GOMove:Tonumber(GUID)) then -- HAD TONUMBER
+                SendAddonMessage(".gomove "..trinityID[ID][1].." "..GUID.." "..ARG, "", "WHISPER", UnitName("player"))
+                if(ID == "GOTO") then
+                    return
+                end
+                did = true
+            end
+        end
+        if(not did) then
+            UIErrorsFrame:AddMessage("No objects selected", 1.0, 0.0, 0.0, 53, 2)
+            return
+        end
+    end
+end
diff --git a/src/server/scripts/Custom/GOMove/GOMove/GOMoveScripts.lua b/src/server/scripts/Custom/GOMove/GOMove/GOMoveScripts.lua
new file mode 100644
index 0000000..02b1688
--- /dev/null
+++ b/src/server/scripts/Custom/GOMove/GOMove/GOMoveScripts.lua
@@ -0,0 +1,429 @@
+GOMove.FavL = {NameWidth = 17}
+function GOMove.FavL:Add(name, guid)
+    self:Del(guid)
+    table.insert(self, 1, {name, guid})
+    GOMoveSV.FavL = self
+end
+function GOMove.FavL:Del(guid)
+    for k,v in ipairs(self) do
+        if(v[2] == guid) then
+            table.remove(self, k)
+            break
+        end
+    end
+    GOMoveSV.FavL = self
+end
+
+GOMove.SelL = {NameWidth = 17}
+function GOMove.SelL:Add(name, guid, entry)
+    table.insert(self, 1, {name, guid, entry})
+end
+function GOMove.SelL:Del(guid)
+    for k,v in ipairs(self) do
+        if(v[2] == guid) then
+            table.remove(self, k)
+            break
+        end
+    end
+end
+
+GOMove.Selected = {}
+function GOMove.Selected:Add(name, guid)
+    self[guid] = name
+end
+function GOMove.Selected:Del(guid)
+    self[guid] = nil
+end
+
+-- FAVOURITE LIST
+local FavFrame = GOMove:CreateFrame("Favourite_List", 200, 280, GOMove.FavL, true)
+FavFrame:Position("BOTTOMRIGHT", UIParent, "BOTTOMRIGHT", 0, 0)
+function FavFrame:ButtonOnClick(ID)
+    GOMove:Move("SPAWN", self.DataTable[FauxScrollFrame_GetOffset(self.ScrollBar) + ID][2])
+end
+function FavFrame:MiscOnClick(ID)
+    self.DataTable:Del(self.DataTable[FauxScrollFrame_GetOffset(self.ScrollBar) + ID][2])
+    self:Update()
+end
+
+-- SELECTION LIST
+local SelFrame = GOMove:CreateFrame("Selection_List", 250, 280, GOMove.SelL, true)
+SelFrame:Position("BOTTOMRIGHT", FavFrame, "TOPRIGHT", 0, 0)
+function SelFrame:ButtonOnClick(ID)
+    local DATAID = FauxScrollFrame_GetOffset(self.ScrollBar) + ID
+    if(GOMove.Selected[self.DataTable[DATAID][2]]) then
+        GOMove.Selected:Del(self.DataTable[DATAID][2])
+    else
+        GOMove.Selected:Add(self.DataTable[DATAID][1], self.DataTable[DATAID][2])
+    end
+    self:Update()
+end
+function SelFrame:MiscOnClick(ID)
+    local DATAID = FauxScrollFrame_GetOffset(self.ScrollBar) + ID
+    GOMove.Selected:Del(self.DataTable[DATAID][2])
+    self.DataTable:Del(self.DataTable[DATAID][2])
+    self:Update()
+end
+function SelFrame:UpdateScript(ID)
+    local DATAID = FauxScrollFrame_GetOffset(self.ScrollBar) + ID
+    if(self.DataTable[DATAID]) then
+        if(GOMove.Selected[self.DataTable[DATAID][2]]) then
+            self.Buttons[ID]:GetFontString():SetTextColor(1, 0.8, 0)
+        else
+            self.Buttons[ID]:GetFontString():SetTextColor(1, 1, 1)
+        end
+    end
+end
+local ClearButton = CreateFrame("Button", SelFrame:GetName().."_ToggleSelect", SelFrame)
+ClearButton:SetSize(16, 16)
+ClearButton:SetNormalTexture("Interface\\Buttons\\UI-GuildButton-PublicNote-Disabled")
+ClearButton:SetPushedTexture("Interface\\Buttons\\UI-GuildButton-OfficerNote-Up")
+ClearButton:SetHighlightTexture("Interface\\Buttons\\UI-GuildButton-PublicNote-Up")
+ClearButton:SetPoint("TOPRIGHT", SelFrame, "TOPRIGHT", -30, -5)
+ClearButton:SetScript("OnClick", function()
+    local empty = true
+    for k,v in pairs(GOMove.Selected) do
+        if(GOMove:Tonumber(k)) then -- HAD TONUMBER
+            empty = false
+        end
+    end
+    if(empty) then
+        for k, tbl in ipairs(SelFrame.DataTable) do
+            GOMove.Selected:Add(tbl[1], tbl[2])
+        end
+    else
+        for k,v in pairs(GOMove.Selected) do
+            if(GOMove:Tonumber(k)) then -- HAD TONUMBER
+                GOMove.Selected:Del(k)
+            end
+        end
+    end
+    SelFrame:Update()
+end)
+for i = 1, SelFrame.ButtonCount do
+    local Button = SelFrame.Buttons[i]
+    local MiscButton = Button.MiscButton
+    local FavButton = CreateFrame("Button", Button:GetName().."_Favourite", MiscButton)
+    FavButton:SetSize(16, 16)
+    FavButton:SetNormalTexture("Interface\\Buttons\\UI-PlusButton-Up")
+    FavButton:SetPushedTexture("Interface\\Buttons\\UI-PlusButton-Down")
+    FavButton:SetHighlightTexture("Interface\\Buttons\\UI-PlusButton-Hilighted")
+    FavButton:SetPoint("TOPRIGHT", MiscButton, "TOPLEFT", 0, 0)
+    FavButton:SetScript("OnClick", function()
+        local DATAID = FauxScrollFrame_GetOffset(SelFrame.ScrollBar) + i
+        FavFrame.DataTable:Add(SelFrame.DataTable[DATAID][1], SelFrame.DataTable[DATAID][3])
+        FavFrame:Update()
+    end)
+    local DeleteButton = CreateFrame("Button", Button:GetName().."_Delete", FavButton)
+    DeleteButton:SetSize(16, 16)
+    DeleteButton:SetNormalTexture("Interface\\PaperDollInfoFrame\\SpellSchoolIcon5")
+    DeleteButton:SetPushedTexture("Interface\\PaperDollInfoFrame\\SpellSchoolIcon7")
+    DeleteButton:SetHighlightTexture("Interface\\PaperDollInfoFrame\\SpellSchoolIcon3")
+    DeleteButton:SetPoint("TOPRIGHT", FavButton, "TOPLEFT", 0, 0)
+    DeleteButton:SetScript("OnClick", function()
+        GOMove:Move("DELETE", SelFrame.DataTable[FauxScrollFrame_GetOffset(SelFrame.ScrollBar) + i][2])
+    end)
+    local SpawnButton = CreateFrame("Button", Button:GetName().."_Spawn", DeleteButton)
+    SpawnButton:SetSize(16, 16)
+    SpawnButton:SetNormalTexture("Interface\\Buttons\\UI-SpellbookIcon-PrevPage-Disabled")
+    SpawnButton:SetPushedTexture("Interface\\Buttons\\UI-SpellbookIcon-PrevPage-Down")
+    SpawnButton:SetHighlightTexture("Interface\\Buttons\\UI-SpellbookIcon-PrevPage-Up")
+    SpawnButton:SetPoint("TOPRIGHT", DeleteButton, "TOPLEFT", 0, 0)
+    SpawnButton:SetScript("OnClick", function()
+        GOMove:Move("RESPAWN", SelFrame.DataTable[FauxScrollFrame_GetOffset(SelFrame.ScrollBar) + i][2])
+    end)
+end
+local EmptyButton = CreateFrame("Button", SelFrame:GetName().."_EmptyButton", SelFrame)
+EmptyButton:SetSize(30, 30)
+EmptyButton:SetNormalTexture("Interface\\Buttons\\CancelButton-Up")
+EmptyButton:SetPushedTexture("Interface\\Buttons\\CancelButton-Down")
+EmptyButton:SetHighlightTexture("Interface\\Buttons\\CancelButton-Highlight")
+EmptyButton:SetPoint("TOPRIGHT", SelFrame, "TOPRIGHT", -45, 0)
+EmptyButton:SetHitRectInsets(9, 7, 7, 10)
+EmptyButton:SetScript("OnClick", function()
+    for k,v in pairs(GOMove.Selected) do
+        if(GOMove:Tonumber(k)) then -- HAD TONUMBER
+            GOMove.Selected:Del(k)
+        end
+    end
+    for i = #SelFrame.DataTable, 1, -1 do
+        SelFrame.DataTable:Del(SelFrame.DataTable[i][2])
+    end
+    SelFrame:Update()
+end)
+
+-- MAIN FRAME
+local MainFrame = GOMove:CreateFrame("GOMove_UI", 170, 455)
+GOMove.MainFrame = MainFrame
+MainFrame:Position("LEFT", UIParent, "LEFT", 0, 85)
+
+local NEWS = GOMove:CreateInput(MainFrame, "NEWS", 40, 25, 0, -50, 4, 30)
+
+local NORTH = GOMove:CreateButton(MainFrame, "N", 50, 25, 0, -25)
+function NORTH:OnClick()
+    GOMove:Move("NORTH", NEWS:GetNumber())
+end
+local EAST = GOMove:CreateButton(MainFrame, "E", 50, 25, 50, -50)
+function EAST:OnClick()
+    GOMove:Move("EAST", NEWS:GetNumber())
+end
+local SOUTH = GOMove:CreateButton(MainFrame, "S", 50, 25, 0, -75)
+function SOUTH:OnClick()
+    GOMove:Move("SOUTH", NEWS:GetNumber())
+end
+local WEST = GOMove:CreateButton(MainFrame, "W", 50, 25, -50, -50)
+function WEST:OnClick()
+    GOMove:Move("WEST", NEWS:GetNumber())
+end
+
+local NORTHEAST = GOMove:CreateButton(MainFrame, "NE", 40, 20, 45, -30)
+function NORTHEAST:OnClick()
+    GOMove:Move("NORTHEAST", NEWS:GetNumber())
+end
+local NORTHWEST = GOMove:CreateButton(MainFrame, "NW", 40, 20, -45, -30)
+function NORTHWEST:OnClick()
+    GOMove:Move("NORTHWEST", NEWS:GetNumber())
+end
+local SOUTHEAST = GOMove:CreateButton(MainFrame, "SE", 40, 20, 45, -75)
+function SOUTHEAST:OnClick()
+    GOMove:Move("SOUTHEAST", NEWS:GetNumber())
+end
+local SOUTHWEST = GOMove:CreateButton(MainFrame, "SW", 40, 20, -45, -75)
+function SOUTHWEST:OnClick()
+    GOMove:Move("SOUTHWEST", NEWS:GetNumber())
+end
+
+local X = GOMove:CreateButton(MainFrame, "X", 35, 20, -60, -105)
+function X:OnClick()
+    GOMove:Move("X")
+end
+local Y = GOMove:CreateButton(MainFrame, "Y", 35, 20, -20, -105)
+function Y:OnClick()
+    GOMove:Move("Y")
+end
+local Z = GOMove:CreateButton(MainFrame, "Z", 35, 20, 20, -105)
+function Z:OnClick()
+    GOMove:Move("Z")
+end
+local O = GOMove:CreateButton(MainFrame, "O", 35, 20, 60, -105)
+function O:OnClick()
+    GOMove:Move("O")
+end
+
+local ROTHEI = GOMove:CreateInput(MainFrame, "ROTHEI", 40, 25, 0, -155, 4, 30)
+local UP = GOMove:CreateButton(MainFrame, "Up", 40, 25, 0, -130)
+function UP:OnClick()
+    GOMove:Move("UP", ROTHEI:GetNumber())
+end
+local DOWN = GOMove:CreateButton(MainFrame, "Down", 40, 25, 0, -180)
+function DOWN:OnClick()
+    GOMove:Move("DOWN", ROTHEI:GetNumber())
+end
+local RIGHT = GOMove:CreateButton(MainFrame, "Right", 40, 25, 45, -155)
+function RIGHT:OnClick()
+    GOMove:Move("RIGHT", ROTHEI:GetNumber())
+end
+local LEFT = GOMove:CreateButton(MainFrame, "Left", 40, 25, -45, -155)
+function LEFT:OnClick()
+    GOMove:Move("LEFT", ROTHEI:GetNumber())
+end
+
+local RESPAWN = GOMove:CreateButton(MainFrame, "Respawn", 65, 25, -35, -237.5)
+function RESPAWN:OnClick()
+    GOMove:Move("RESPAWN")
+end
+local SAVE = GOMove:CreateButton(MainFrame, "Save", 65, 25, 35, -237.5)
+function SAVE:OnClick()
+    GOMove:Move("SAVE")
+end
+local SELECTNEAR = GOMove:CreateButton(MainFrame, "Target", 50, 25, 55, -210)
+function SELECTNEAR:OnClick()
+    GOMove:Move("SELECTNEAR")
+end
+local FACE = GOMove:CreateButton(MainFrame, "Snap", 50, 25, 0, -210)
+function FACE:OnClick()
+    GOMove:Move("FACE")
+end
+local DELETE = GOMove:CreateButton(MainFrame, "Delete", 50, 25, -55, -210)
+function DELETE:OnClick()
+    GOMove:Move("DELETE")
+end
+
+local GROUND = GOMove:CreateButton(MainFrame, "Ground", 70, 25, -40, -265)
+function GROUND:OnClick()
+    GOMove:Move("GROUND")
+end
+local GOTO = GOMove:CreateButton(MainFrame, "Go to", 70, 25, 40, -265)
+function GOTO:OnClick()
+    GOMove:Move("GOTO")
+end
+
+local ENTRY = GOMove:CreateInput(MainFrame, "ENTRY", 65, 25, -30, -295, 10)
+local SPAWN = GOMove:CreateButton(MainFrame, "Spawn", 50, 25, 40, -295)
+function SPAWN:OnClick()
+    GOMove:Move("SPAWN", ENTRY:GetNumber())
+end
+
+local RADIUS = GOMove:CreateInput(MainFrame, "RADIUS", 40, 25, -55, -325, 4)
+local SELECTALLNEAR = GOMove:CreateButton(MainFrame, "Select by radius", 110, 25, 25, -325)
+function SELECTALLNEAR:OnClick()
+    GOMove:Move("SELECTALLNEAR", RADIUS:GetNumber())
+end
+
+local MASK = GOMove:CreateInput(MainFrame, "MASK", 65, 25, -30, -355, 10)
+local PHASE = GOMove:CreateButton(MainFrame, "Phase", 50, 25, 40, -355)
+function PHASE:OnClick()
+    GOMove:Move("PHASE", MASK:GetNumber())
+end
+
+local FAVOURITES = GOMove:CreateButton(MainFrame, "Favourites", 80, 25, -40, -385)
+function FAVOURITES:OnClick()
+    if(FavFrame:IsVisible()) then
+        FavFrame:Hide()
+    else
+        FavFrame:Show()
+    end
+end
+local SELECTIONS = GOMove:CreateButton(MainFrame, "Selections", 80, 25, 40, -385)
+function SELECTIONS:OnClick()
+    if(SelFrame:IsVisible()) then
+        SelFrame:Hide()
+    else
+        SelFrame:Show()
+    end
+end
+
+local SPELLENTRY = GOMove:CreateInput(MainFrame, "SPELLENTRY", 65, 25, -30, -415, 10)
+local SPELLSPAWN = GOMove:CreateButton(MainFrame, "Send", 50, 25, 40, -415)
+function SPELLSPAWN:OnClick()
+    GOMove:Move("SPAWNSPELL", SPELLENTRY:GetNumber())
+end
+
+GOMove.SCMD = {}
+function GOMove.SCMD.help()
+    for k, v in pairs(GOMove.SCMD) do
+        print(k)
+    end
+end
+function GOMove.SCMD.reset()
+    for k, inputfield in ipairs(GOMove.Inputs) do
+        inputfield:ClearFocus()
+    end
+    print("Frames reset")
+    for k, Frame in pairs(GOMove.Frames) do
+        if(Frame.Default) then
+            Frame:ClearAllPoints()
+            Frame:SetPoint(Frame.Default[1], Frame.Default[2], Frame.Default[3], Frame.Default[4], Frame.Default[5])
+        end
+        Frame:Show()
+    end
+end
+function GOMove.SCMD.tempsave()
+    for k, name in pairs(SelFrame.Selected) do
+        local n, h = GOMove:Tonumber(k)
+        if(n and h) then
+            GOMove:Move("SAVE", k)
+        end
+    end
+end
+function GOMove.SCMD.invertselection()
+    local sel = {}
+    for GUID, NAME in pairs(GOMove.Selected) do
+        if(GOMove:Tonumber(GUID)) then -- HAD TONUMBER
+            table.insert(sel, GUID)
+        end
+    end
+    for k, tbl in ipairs(SelFrame.DataTable) do
+        GOMove.Selected:Add(tbl[1], tbl[2])
+    end
+    for k,v in ipairs(sel) do
+        GOMove.Selected:Del(v)
+    end
+    SelFrame:Update()
+end
+
+SLASH_GOMOVE1 = '/gomove'
+function SlashCmdList.GOMOVE(msg, editBox)
+    if(msg ~= '') then
+        for k, v in pairs(GOMove.SCMD) do
+            if(type(k) == "string" and string.find(k, msg:lower()) == 1 and type(v) == "function") then
+                v()
+                break;
+            end
+        end
+        return
+    end
+    if(MainFrame:IsVisible()) then
+        MainFrame:Hide()
+    else
+        MainFrame:Show()
+    end
+end
+
+local EventFrame = CreateFrame("Frame")
+EventFrame:RegisterEvent("ADDON_LOADED")
+EventFrame:RegisterEvent("CHAT_MSG_ADDON")
+
+EventFrame:SetScript("OnEvent",
+    function(self, event, MSG, _, Type, Sender)
+        if(event == "CHAT_MSG_ADDON" and Sender == UnitName("player")) then
+            local ID, ENTRYORGUID, ARG2, ARG3 = MSG:match("^GOMOVE|(.+)|([%a%d]+)|(.*)|([%a%d]+)$")
+            if(ID) then
+                --if(ID == "USED") then
+                --    for k,v in ipairs(GOMove.UseL) do
+                --        if(ENTRYORGUID == v[2]) then
+                --            return
+                --        end
+                --    end
+                --    GOMove.UseL:Add(ARG2, ENTRYORGUID)
+                --    GOMove:Update()
+                if(ID == "REMOVE") then
+                    local guid = ENTRYORGUID
+                    GOMove.Selected:Del(guid)
+                    for k,tbl in ipairs(GOMove.SelL) do
+                        if(tbl[2] == guid) then
+                            GOMove.SelL:Del(guid)
+                            break
+                        end
+                    end
+                    GOMove:Update()
+                elseif(ID == "ADD") then
+                    local guid = ENTRYORGUID
+                    GOMove.Selected:Add(ARG2, guid)
+                    local exists = false
+                    for k, tbl in ipairs(GOMove.SelL) do
+                        if(tbl[2] == guid) then
+                            exists = true
+                            break
+                        end
+                    end
+                    if(not exists) then
+                        GOMove.SelL:Add(ARG2, guid, ARG3)
+                    end
+                    GOMove:Update()
+                elseif(ID == "SWAP") then
+                    local oldGUID, newGUID = ENTRYORGUID, ARG3
+                    GOMove.Selected:Add(GOMove.Selected[oldGUID], newGUID)
+                    GOMove.Selected:Del(oldGUID)
+                    for k,tbl in ipairs(GOMove.SelL) do
+                        if(tbl[2] == oldGUID) then
+                            tbl[2] = newGUID
+                            break
+                        end
+                    end
+                    GOMove:Update()
+                end
+            end
+        elseif(MSG == "GOMove" and event == "ADDON_LOADED") then
+            if(not GOMoveSV or type(GOMoveSV) ~= "table") then
+                GOMoveSV = {}
+            end
+            if(GOMoveSV.FavL) then
+                for k,v in ipairs(GOMoveSV.FavL) do
+                    GOMove.FavL[k] = v
+                end
+            end
+            GOMove:Update()
+        end
+    end
+)
diff --git a/src/server/scripts/Custom/GOMove/GOMove/MapButton.xml b/src/server/scripts/Custom/GOMove/GOMove/MapButton.xml
new file mode 100644
index 0000000..db7280b
--- /dev/null
+++ b/src/server/scripts/Custom/GOMove/GOMove/MapButton.xml
@@ -0,0 +1,75 @@
+<Ui>
+    <Button name="GOMove_UI_MapButton" text="G" parent="Minimap" toplevel="true" movable="true" frameStrata="LOW" enableMouse="true">
+        <Size x="27" y="27" />
+        <Anchors>
+            <Anchor point="TOPLEFT" x="-25" y="-60" />
+        </Anchors>
+        <Scripts>
+            <OnLoad>
+                this:RegisterForClicks("LeftButtonUp","RightButtonUp","MiddleButtonUp");
+                this:RegisterForDrag("RightButton");
+            </OnLoad>
+            <OnEnter>
+                GameTooltip:SetOwner(this, "ANCHOR_LEFT");
+                GameTooltip:AddLine("GOMove UI");
+                GameTooltip:AddLine("Type /gomove to show or hide the GOMove window");
+                GameTooltip:AddLine("Type /gomove reset to reset the gomove UI positions");
+                GameTooltip:AddLine(" ");
+                GameTooltip:AddLine("Left click to show/hide");
+                GameTooltip:AddLine("Right click to drag this");
+                GameTooltip:Show();
+            </OnEnter>
+            <OnLeave>
+                GameTooltip:Hide();
+            </OnLeave>
+            <OnClick>
+                if(GOMove.MainFrame:IsVisible()) then
+                    GOMove.MainFrame:Hide()
+                else
+                    GOMove.MainFrame:Show()
+                end
+            </OnClick>
+            <OnDragStart>
+                this:StartMoving();
+            </OnDragStart>
+            <OnDragStop>
+                this:StopMovingOrSizing();
+            </OnDragStop>
+        </Scripts>
+        <Layers>
+            <Layer level="OVERLAY">
+                <Texture name="Texture1" file="Interface\Minimap\MiniMap-TrackingBorder">
+                    <Size>
+                        <AbsDimension x="46" y="46" />
+                    </Size>
+                    <Anchors>
+                        <Anchor point="TOPLEFT" />
+                    </Anchors>
+                </Texture>
+            </Layer>
+            <Layer level="BACKGROUND">
+                <Texture name="$parent_Texture">
+                    <Size>
+                        <AbsDimension x="15" y="15" />
+                    </Size>
+                    <Anchors>
+                        <Anchor point="TOPLEFT">
+                            <Offset>
+                                <AbsDimension x="6" y="-6" />
+                            </Offset>
+                        </Anchor>
+                    </Anchors>
+                    <TexCoords left="0.075" right="0.925" top="0.075" bottom="0.925" />
+                </Texture>
+            </Layer>
+        </Layers>
+        <ButtonText name="$parentText">
+            <FontHeight>
+                <AbsValue val="10" />
+            </FontHeight>
+        </ButtonText>
+        <NormalFont style="GameFontNormal" />
+        <HighlightFont style="GameFontHighlight" />
+        <DisabledFont style="GameFontDisable" />
+    </Button>
+</Ui>
diff --git a/src/server/scripts/Custom/GOMove/Guide.jpg b/src/server/scripts/Custom/GOMove/Guide.jpg
new file mode 100644
index 0000000..8e19437
Binary files /dev/null and b/src/server/scripts/Custom/GOMove/Guide.jpg differ
diff --git a/src/server/scripts/Custom/GOMove/README.md b/src/server/scripts/Custom/GOMove/README.md
new file mode 100644
index 0000000..15ff853
--- /dev/null
+++ b/src/server/scripts/Custom/GOMove/README.md
@@ -0,0 +1,53 @@
+#GOMove [![Build Status](https://travis-ci.org/Rochet2/TrinityCore.svg?branch=gomove)](https://travis-ci.org/Rochet2/TrinityCore)
+
+####About
+GOMove is a script that allows you to move objects.
+
+You no longer need to be at the point where you want to spawn an object
+and you can fine tune the position of objects (rotation and x,y,z position)
+
+Some features:
+- Move objects (to compass directions and according to your character position)
+- Favourite list
+- Snap facing to a compass direction (N,E,W,S)
+- Spawn an object again
+- move to ground level
+
+Source: http://rochet2.github.io/GOMove.html  
+Original idea by [Mordred](https://www.youtube.com/watch?v=a0JVXJ07KUU)
+
+####Installation
+
+Available as:
+- Direct merge: https://github.com/Rochet2/TrinityCore/tree/gomove
+- Diff: https://github.com/Rochet2/TrinityCore/compare/TrinityCore:3.3.5...gomove.diff
+- Diff in github view: https://github.com/Rochet2/TrinityCore/compare/TrinityCore:3.3.5...gomove
+
+Using direct merge:
+- open git bash to source location
+- do `git remote add rochet2 https://github.com/Rochet2/TrinityCore.git`
+- do `git pull rochet2 gomove`
+- use cmake and compile
+- Copy the GOMove addon folder (GOMove folder with lua files inside) to `WowInstallFolder\Interface\AddOns`
+
+Using diff:
+- DO NOT COPY THE DIFF DIRECTLY! It causes apply to fail.
+- download the diff by __right clicking__ the link and select __Save link as__
+- place the downloaded `gomove.diff` to the source root folder
+- open git bash to source location
+- do `git apply gomove.diff`
+- use cmake and compile
+- Copy the GOMove addon folder (GOMove folder with lua files inside) to `WowInstallFolder\Interface\AddOns`
+
+Want to place objects with a spell (green targetting circle)?
+- execute this to world database `INSERT INTO spell_script_names (spell_id, ScriptName) VALUES (27651, 'GOMove_spell_place');`
+- learn spell `27651`
+- Now you can put the entry of the object in Send input box and click Send. Then you can spawn the object with the spell. All objects spawned will be saved for the spell spawning aswell (spawned from favourites list for example)
+
+####Usage
+Install to server, enable the addon on client side and go ingame.
+You will see the addon display as you log in and you should see a minmap icon with a G on it.
+In game chat use `/gomove help` to see all commands
+Note! Only game objects showing the real guid (not hex) are actually saved. If you save an object and then move it, it is again only temporary.
+
+[![Guide.jpg](Guide.jpg)](https://raw.githubusercontent.com/Rochet2/TrinityCore/gomove/src/server/scripts/Custom/GOMove/Guide.jpg)
